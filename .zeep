#!/usr/bin/env zsh
# Zsh Enhanced Error Printing. Zeep!
# Captures and formats command errors in a readable format when commands fail

# Optimizing prexec() so it only flags certain commands for capture

preexec() {
  LAST_COMMAND=$1
  
  # Skip capture for interactive apps that need direct terminal access
  case "${LAST_COMMAND%% *}" in
    pacman|brew|git|nv|nvim|vim|vi|nano|less|more|man|htop|top|ssh)
      SKIP_CAPTURE=true
      return
      ;;
  esac
  
  SKIP_CAPTURE=false
  TMP_ERROR_FILE="/tmp/zsh_error_output_$"
  
  # Check if this command needs stdout capture (tools that output errors to stdout)
  NEEDS_STDOUT=false
  case "${LAST_COMMAND%% *}" in
    cmake|make|ninja|bazel)
      NEEDS_STDOUT=true
      TMP_OUTPUT_FILE="/tmp/zsh_stdout_output_$"
      ;;
  esac
  
  # Always capture stderr
  exec {STDERR_FD}>&2
  exec 2>"$TMP_ERROR_FILE"
  
  # Selectively capture stdout only for tools that need it
  if [[ "$NEEDS_STDOUT" == true ]]; then
    exec {STDOUT_FD}>&1
    exec 1> >(tee "$TMP_OUTPUT_FILE" >&${STDOUT_FD})
  fi
}

# Simple error display
precmd() {
  EXIT_CODE=$?

  # Skip if we skipped capture
  if [[ "$SKIP_CAPTURE" == true ]]; then
    return
  fi

  # Restore file descriptors
  if [[ -n "$STDERR_FD" ]]; then
    exec 2>&${STDERR_FD}
    exec {STDERR_FD}>&-
    unset STDERR_FD
  fi
  
  if [[ -n "$STDOUT_FD" ]]; then
    exec 1>&${STDOUT_FD}
    exec {STDOUT_FD}>&-
    unset STDOUT_FD
  fi

  # Show error box only for failed commands
  if [[ $EXIT_CODE -ne 0 ]]; then
    local error_output=""
    
    # Always check stderr first
    if [[ -f "$TMP_ERROR_FILE" && -s "$TMP_ERROR_FILE" ]]; then
      error_output=$(<"$TMP_ERROR_FILE")
    fi
    
    # If no stderr content and we captured stdout, check stdout for errors
    if [[ -z "$error_output" && "$NEEDS_STDOUT" == true && -f "$TMP_OUTPUT_FILE" && -s "$TMP_OUTPUT_FILE" ]]; then
      local stdout_content=$(<"$TMP_OUTPUT_FILE")
      # Simple check for common error patterns
      if echo "$stdout_content" | grep -qiE "error|failed|fatal|cannot"; then
        error_output="$stdout_content"
      fi
    fi

    if [[ -n "$error_output" ]]; then
      local fg="\e[38;2;255;179;179m"
      local reset="\e[0m"
      local line_width=90
      local border=$(printf "%*s" $((line_width - 2)) "" | tr ' ' '─')
      
      echo -e ""
      echo -e "${fg}╭${border}╮${reset}"
      printf "${fg}│ ✖ Command failed (exit code:%03d): %-*.*s│${reset}\n" "$EXIT_CODE" $((line_width - 37)) $((line_width - 37)) "$LAST_COMMAND" 
      echo -e "${fg}├${border}┤${reset}"
      
      # Show error lines - simplified processing
      echo "$error_output" | head -15 | while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        # Basic cleanup - remove control chars
        line=$(echo "$line" | tr -d '\r' | sed 's/\x1b\[[0-9;]*m//g')
        # Truncate if too long
        if [[ ${#line} -gt $((line_width - 4)) ]]; then
          line="${line:0:$((line_width - 5))}..."
        fi
        printf "${fg}│ %-*s │${reset}\n" $((line_width - 4)) "$line"
      done
      
      echo -e "${fg}╰${border}╯${reset}"
      echo -e ""
    fi
  fi

  # Cleanup
  [[ -f "$TMP_ERROR_FILE" ]] && rm -f "$TMP_ERROR_FILE"
  [[ -f "$TMP_OUTPUT_FILE" ]] && rm -f "$TMP_OUTPUT_FILE"
}
